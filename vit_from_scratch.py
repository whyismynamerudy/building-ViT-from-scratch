# -*- coding: utf-8 -*-
"""ViT_from_scratch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13x5Q4swCaxuYl34WcUV7SpIDgV2GStVZ

General Idea behind ViTs: split the input image into "patches" and flatten them
into a one-dimensional vector and, with an additional positional encoding, its
all fed into a transformer encoder.
"""

import torch
import torch.nn as nn

class PatchEmbed(nn.Module):
  """
  Split images into patches and embed them.

  Params:

    img_size: int
      size of the image (it is a square)

    patch_size: int
      size of the patch (square)

    in_chans: int
      num of input channels

    embed_dim: int
      embedding dimension

  Attr:

    num_patches: int
      number of patches inside the image

    proj: nn.Conv2D - use it to split images into patches

  """

  def __init__(self, img_size, patch_size, in_chans = 3, embed_dim=768):
    super().__init__()
    self.img_size = img_size
    self.patch_size = patch_size
    self.num_patches = (img_size // patch_size) ** 2

    self.proj = nn.Conv2D(
        in_chans,
        embed_dim,
        kernel_size = patch_size,
        stride = patch_size
    )

  def forward(self, x):
    """
    Perform Forward pass of data.

    x : torch.Tensor (just a batch of images)
      Shape: (n_samples, in_chans, img_size, img_size)

    returns: torch.Tensor
      Shape: (n_samples, num_patches, embed_dim)
    """
    x = self.proj(x)  # (n_samples, embed_dim, num_patches ** 0.5, num_patches ** 0.5)
    # ** 0.5 since its num_patches along width/height
    # whereas num_patches = total # of patches in the image

    x = x.flatten(2)  # (n_samples, embed_dim, num_patches)
    x = x.transpose(1, 2) # (n_samples, num_patches, embed_dim)

    return x


class Attention(nn.Module):
  """
  Attention Mechanism.

  Params:

    dim : int, input and out dimension of per token features
    n_heads : int
    qkv_bias : bool, if True include bias to query, key, and value projections
    attn_p : float, dropout prob for q, k, v tensors
    proj_p : float, dropout prob for the output tensor

  Attr:

    scale : float, normalizing constant for dot prod
    qkv : nn.Linear, linear proj for q, k, v
    proj : nn.Linear, maps concatenated output of attention heads to new space
    attn_drop, proj_drop : nn.Dropout, dropout layers
  """

  def __init__(self, dim, n_heads=12, qkv_bias=True, attn_p=0., proj_p=0.):
    super().__init__()
    self.dim = dim
    self.n_heads = n_heads
    self.head_dim = (dim // n_heads)
    self.scale = self.head_dim ** -0.5 # scale from the original attention paper

    self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias) # generating qkv from input token embedding
    self.attn_drop = nn.Dropout(attn_p)
    self.proj = nn.Linear(dim, dim)
    self.proj_drop = nn.Dropout(proj_p)

  def forward(self, x):
    """
    Run forward pass.

    x : torch.Tensor
      shape: (n_samples, n_patches + 1, dim)

    returns : torch.Tensor
      shape: (n_samples, n_patches + 1, dim)

    # n_patches + 1 because we will always have class token as first token in sequence
    """
    n_samples, n_tokens, dim = x.shape

    if dim != self.dim:
      raise ValueError

    qkv = self.qkv(x) # (n_samples, n_patches + 1, 3 * dim)
    qkv = qkv.reshape(
        n_samples, n_tokens, 3, self.n_heads, self.head_dim
    ) # (n_samples, n_patches + 1, 3, n_heads, head_dim)
    qkv = qkv.permute(
        2, 0, 3, 1, 4
    ) # 3, n_samples, n_heads, n_patches + 1, head_dim

    q, k, v = qkv[0], qkv[1], qkv[2]
    k_t = k.transpose(-2, -1) #(n_samples, n_heads, head_dim, n_patches + 1)

    dp = (q @ k_t) * self.scale #(n_samples, n_heads, n_patches + 1, n_patches + 1)

    attn = dp.softmax(dim=-1) #(n_samples, n_heads, n_patches + 1, n_patches + 1)
    attn = self.attn_drop(attn)

    weighted_avg = attn @ v #(n_samples, n_heads, n_patches + 1, head_dim)
    weighted_avg = weighted_avg.transpose(
        1, 2
    ) #(n_samples, n_patches + 1, n_heads, head_dim)
    weighted_avg = weighted_avg.flatten(2) #(n_samples, n_patches + 1, dim)

    x = self.proj(weighted_avg) # (n_samples, n_patches + 1, dim)
    x = self.proj_drop(x)

    return x



class MLP(nn.Module):
  """
  MultiLayer Perceptron

  Params:
    in_features : int
    hidden_features : int, num nodes in hidden layer
    out_features : int
    p : float, dropout prob

  Attr:
    fc1 : nn.Linear, first linear layer
    act : nn.GELU
    fc2 : nn.Linear, second hidden layer
    drop : nn.Dropout

  """
  def __init__(self, in_features, hidden_features, out_features, p=0.):
    super().__init__()
    self.fc1 = nn.Linear(in_features, hidden_features)
    self.act = nn.GELU()
    self.fc2(hidden_features, out_features)
    self.drop = nn.Dropout(p)

  def forward(self, x):
    """
    Run forward pass.


    x : torch.Tensor
      shape: (n_samples, num_patches + 1, in_features)

    returns : torch.Tensor
      shape: (n_samples, num_patches + 1, out_features)
    """
    x = self.fc1(x)
    x = self.act(x)
    x = self.drop(x)
    x = self.fc(x)
    out = self.drop(x)

    return out



class Block(nn.Module):
  """
  Transformer Block.

  dim : int, embedding dim
  n_heads : int, number of attention heads.
  mlp_ratio : float, determines hidden dim size of mlp module w.r.t dim
  qkv_bias : bool,
  p, attn_p : float
  """
  def __init__(self, dim, n_heads, mlp_ratio=4.0, qkv_bias=True, p=0., attn_p=0.):
    super().__init__()
    self.norm1 = nn.LayerNorm(dim, eps=1e-6)
    self.attn = Attention(dim, n_heads = n_heads, qkv_bias = qkv_bias, attn_p = attn_p,
                          proj_p=p)
    self.norm2 = nn.LayerNorm(dim, eps=1e-6)

    hidden_features = int(mlp_ratio * dim)
    self.mlp = MLP(dim, hidden_features, dim)

  def forward(self, x):
    x = x + self.attn(self.norm1(x))
    x = x + self.mlp(self.norm2(x))

    return x #(n_samples, n_patches + 1, dim)


class VIT(nn.Module):
  """
  Simplified implementation of the vision transformer.

  img_size : int
  patch_size : int
  in_chans : int
  n_classes : int
  embed_dim : int, dimensionality of token/patch embedding
  depth : int, number of transformer blocks (Block)
  n_heads : int
  mlp_ratio : float
  qkv_bias : bool
  p, attn_p : float

  Attr:

  patch_embed : PatchEmbed class
  cls_token : nn.Parameter, learnable parameter that will represent the first
              token in the sequence. It has 'embed_dim' elements.
  pos_emd : nn.Paramter, positional embedding of all cls tokens + all the patches.
            It has (n_patches + 1) * embed_dim elements
  pos_drop : nn.Dropout
  blocks : nn.ModuleList, list of Block modules
  norm : nn.LayerNorm
  """
  def __init__(self, img_size=384, patch_size=16, in_chans=3, n_classes=1000,
              embed_dim=768, depth=12, n_heads=12, mlp_ratio=0.4, qkv_bias=True,
               p=0., attn_p=0.):

    super().__init__()

    self.patch_embed = PatchEmbed(
        img_size = img_size,
        patch_size=patch_size,
        in_chans=in_chans,
        embed_dim=embed_dim
    )

    self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim))
    self.pos_embed = nn.Paramter(
        torch.zeros(1, 1 + self.patch_embed.num_patches, embed_dim)
    )
    self.pos_drop = nn.Dropout(p)

    self.blocks = nn.ModuleList(
        [
            Block(
                dim=embed_dim,
                n_heads=n_heads,
                mlp_ratio=mlp_ratio,
                qkv_bias=qkv_bias,
                p=p,
                attn_p=attn_p
            ) for _ in range(depth)
        ]
    )

    self.norm = nn.LayerNorm(embed_dim, eps=1e-6)
    self.head = nn.Linear(embed_dim, n_classes)

  def forward(self, x):
    """
    Forward Pass.

    input: x, torch.Tensor
      shape: (n_samples, in_chans, img_Size, img_size)

    output: logits, shape (n_samples, n_classes)
    """
    n_samples = x.shape[0]
    x = self.patch_embed(x)

    cls_token = self.cls_token.expand(
        n_samples, -1, -1
    ) # take class token and replicate it over sample dimension
    # (n_samples, 1, embed_dim)

    x = torch.cat((cls_token, x), dim=1) # (n_samples, 1 + num_patches, embed_dim)
    x = x + self.pos_embed # (n_samples, 1 + num_patches, embed_dim)
    x = self.pos_drop(x)

    for block in self.blocks:
      x = block(x)

    x = self.norm(x)

    cls_token_final = x[:, 0] # select just the class embedding
    x = self.head(cls_token_final)

    return x